<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Balloon Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin:0; padding:0; overflow: hidden; background: #b3e5fc; height: 100%; width: 100%; }
    #score {
      position: absolute; top: 16px; left: 20px; color: #fff; font-size: 1.5rem;
      background: rgba(44,83,100,0.6); border-radius: 10px; padding: 7px 22px; z-index: 2;
      font-family: Arial, sans-serif; letter-spacing: 1.5px; box-shadow: 0 2px 16px #0003;
    }
    #info {
      position: absolute; top: 16px; right: 20px; color: #fff; font-size: 1rem;
      background: rgba(0,0,0,0.25); border-radius: 10px; padding: 7px 16px; z-index: 2;
      font-family: Arial, sans-serif; letter-spacing: 0.5px; box-shadow: 0 2px 12px #0001;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="info">Tap or Click Balloons!</div>
  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, raycaster, mouse, balloons = [], score = 0, popping = false;

    // Setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 18);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Lighting
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(0, 2, 4);
    scene.add(sun);
    const amb = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(amb);

    // Sky Gradient
    {
      const skyGeo = new THREE.SphereGeometry(200,32,32);
      const skyMat = new THREE.MeshBasicMaterial({color: 0xb3e5fc, side:THREE.BackSide});
      const sky = new THREE.Mesh(skyGeo, skyMat);
      scene.add(sky);
    }

    // Balloon Geometry/Material
    function createBalloon() {
      const colors = [0xff1744, 0xffea00, 0x00e676, 0x2979ff, 0xd500f9, 0xff9100];
      const color = colors[Math.floor(Math.random() * colors.length)];
      const geometry = new THREE.SphereGeometry(0.65, 24, 24);
      geometry.scale(1, 1.25, 1);
      const material = new THREE.MeshPhongMaterial({color, shininess: 90, specular: 0xffffff});
      const balloon = new THREE.Mesh(geometry, material);
      balloon.position.x = (Math.random() - 0.5) * 10;
      balloon.position.y = -9;
      balloon.position.z = (Math.random() - 0.5) * 3;
      balloon.userData = { speed: 0.018 + Math.random()*0.012, popping: false };
      // String
      const lineMat = new THREE.LineBasicMaterial({ color: 0x333 });
      const points = [ new THREE.Vector3(0, -1.1, 0), new THREE.Vector3(0, -2.2, 0) ];
      const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), lineMat);
      balloon.add(line);
      return balloon;
    }

    function spawnBalloon() {
      const balloon = createBalloon();
      scene.add(balloon);
      balloons.push(balloon);
    }

    // Pop effect: scale up and fade out
    function popBalloon(balloon) {
      balloon.userData.popping = true;
      // Optional: add pop sound here
    }

    // Spawn balloons over time
    setInterval(() => {
      if (balloons.length < 12) spawnBalloon();
    }, 600);

    // Handle resizing
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Handle click/tap for popping
    renderer.domElement.addEventListener('pointerdown', (event) => {
      mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
      mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(balloons);
      if (intersects.length > 0) {
        const balloon = intersects[0].object;
        if (!balloon.userData.popping) {
          popBalloon(balloon);
          score++;
          document.getElementById('score').textContent = 'Score: ' + score;
        }
      }
    });

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      for (let i = balloons.length-1; i >= 0; i--) {
        let b = balloons[i];
        if (b.userData.popping) {
          b.scale.multiplyScalar(1.13);
          b.material.opacity = (b.material.opacity||1) * 0.80;
          b.material.transparent = true;
          if (b.scale.x > 2.2) {
            scene.remove(b);
            balloons.splice(i,1);
          }
        } else {
          b.position.y += b.userData.speed;
          b.rotation.y += 0.01;
          if (b.position.y > 11) {
            scene.remove(b);
            balloons.splice(i,1);
          }
        }
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
