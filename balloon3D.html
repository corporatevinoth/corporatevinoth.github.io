<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Zombie Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
      height: 100%;
      width: 100%;
      touch-action: none; /* Prevents default touch actions like scrolling/zooming */
    }
    canvas {
      display: block;
      touch-action: none; /* Ensures canvas itself doesn't scroll/zoom */
    }
    #score {
      position: absolute; top: 16px; left: 20px; color: #fff; font-size: 1.5rem;
      background: rgba(44,83,100,0.6); border-radius: 10px; padding: 7px 22px; z-index: 2;
      font-family: Arial, sans-serif; letter-spacing: 1.5px; box-shadow: 0 2px 16px #0003;
    }
    /* The info pallet is now hidden by default in HTML: style="display:none;" */
    #mute-btn {
      position: absolute;
      top: 16px;
      right: 20px;
      z-index: 10;
      background: rgba(44,83,100,0.6);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 16px #0003;
      border: none;
      outline: none;
      transition: background 0.2s;
      padding: 0;
    }
    #mute-btn:active { background: rgba(44,83,100,0.8); }
    #mute-btn svg { width: 28px; height: 28px; }
    @media (max-width: 700px) {
      #score { font-size: 1.1rem; padding: 5px 13px;}
      #info { font-size: 0.8rem; padding: 5px 9px;}
      #mute-btn { width:34px; height:34px; top: 9px; right: 9px;}
      #mute-btn svg { width:20px; height:20px; }
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="info" style="display:none;">Drag to move the gun. Shoot falling creatures!</div> 
  
  <button id="mute-btn" aria-label="Mute/unmute sound">
    <svg id="sound-on" viewBox="0 0 24 24" fill="none"><path d="M5 9v6h4l5 5V4l-5 5H5z" fill="#fff"/><path d="M16.5 12c0-1.77-.77-3.29-2-4.29v8.58c1.23-1 2-2.52 2-4.29z" fill="#fff"/></svg>
    <svg id="sound-off" viewBox="0 0 24 24" fill="none" style="display:none"><path d="M16.5 12c0-1.77-.77-3.29-2-4.29v8.58c1.23-1 2-2.52 2-4.29z" fill="#fff"/><path d="M5 9v6h4l5 5V4l-5 5H5z" fill="#fff"/><line x1="19" y1="5" x2="5" y2="19" stroke="#fff" stroke-width="2"/></svg>
  </button>
  <audio id="zombie-hit-sound" src="https://cdn.pixabay.com/audio/2022/10/16/audio_12d9e.mp3"></audio>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, gun, bullets = [];
    let fallingObjects = []; // Combined array for zombies and aliens
    let score = 0;
    let GUN_Y; // Will be calculated dynamically
    let GUN_X_LIMIT; // Will be calculated dynamically
    let gunMoving = false, soundMuted = false;
    let targetGunX = 0;
    const dragSensitivity = 0.15; 

    // Sound setup
    const zombieHitSound = document.getElementById('zombie-hit-sound');
    zombieHitSound.volume = 0.2; 

    const muteBtn = document.getElementById('mute-btn');
    const soundOnIcon = document.getElementById('sound-on');
    const soundOffIcon = document.getElementById('sound-off');

    let audioContext; 
    let audioUnlocked = false; // Flag to track if audio context is resumed

    function setMuteUI(muted) {
      soundOnIcon.style.display = muted ? "none" : "";
      soundOffIcon.style.display = muted ? "" : "none";
    }

    // Mute button just toggles sound state, audio context is handled by pointerdown
    muteBtn.addEventListener('click', () => {
      soundMuted = !soundMuted;
      setMuteUI(soundMuted);
    });

    // Three.js setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 22); // Camera distance from origin

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.DirectionalLight(0xffffff, 0.7).position.set(0, 3, 7));
    scene.add(new THREE.AmbientLight(0xffffff, 0.5)); // Slightly brighter ambient light
    scene.add(new THREE.Mesh(
      new THREE.SphereGeometry(200,32,32),
      new THREE.MeshBasicMaterial({color: 0x23272a, side:THREE.BackSide})
    ));

    // Dynamic camera and gun placement based on viewport
    function updateCameraAndGunPlacement() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Calculate visible height and width in world coordinates at Z=camera.position.z
        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const visibleHeight = 2 * Math.tan(fovRad / 2) * camera.position.z;
        const visibleWidth = visibleHeight * camera.aspect;

        const gunModelHeight = 2.3; // Approximate total height of the gun model from its base
        const gunModelHalfWidth = 0.6 / 2; // Approximate half width of the gun body (0.6 width)
        const marginBottom = 0.5; // Small margin from the very bottom of the screen
        const marginSides = 0.5; // Small margin from the sides of the screen

        // Position gun's origin (its base) relative to the bottom edge of the visible screen
        GUN_Y = -(visibleHeight / 2) + marginBottom;

        // Set gun's horizontal limits based on visible width
        GUN_X_LIMIT = (visibleWidth / 2) - gunModelHalfWidth - marginSides;

        // Apply initial gun position after calculation or update existing gun position
        if (gun) { 
            gun.position.y = GUN_Y;
            // gun.position.x = 0; // Not resetting x as user might be moving it
        }
    }

    // Gun Model - Modified to point upwards
    function createGun() {
      const gunGroup = new THREE.Group();
      // Body of the gun (base)
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.8, 0.5), 
        new THREE.MeshPhongMaterial({color: 0x333333, shininess: 100}) // Added shininess
      );
      body.position.y = 0.4; 

      // Barrel of the gun
      const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.14, 0.14, 1.5, 18), 
        new THREE.MeshPhongMaterial({color: 0x90caf9, shininess: 100}) // Added shininess
      );
      barrel.position.y = 0.8 + (1.5 / 2); 

      // Muzzle (top of the barrel)
      const muzzle = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 12, 12),
        new THREE.MeshPhongMaterial({color: 0xffab00, shininess: 100}) // Added shininess
      );
      muzzle.position.y = 0.8 + 1.5; 

      gunGroup.add(body);
      gunGroup.add(barrel);
      gunGroup.add(muzzle);
      gunGroup.position.set(0, GUN_Y, 0); 
      return gunGroup;
    }

    // Call update function once initially and then create gun
    updateCameraAndGunPlacement();
    gun = createGun();
    scene.add(gun);

    // Gun movement (touch/mouse)
    renderer.domElement.addEventListener("pointerdown", e => {
      gunMoving = true;
      targetGunX = calculateTargetX(e);

      // Attempt to resume audio context on first pointerdown
      if (!audioUnlocked) {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log('AudioContext resumed via pointerdown!');
            audioUnlocked = true;
          }).catch(err => console.error("Failed to resume AudioContext on pointerdown:", err));
        } else { // Already running
          audioUnlocked = true;
        }
      }
    });

    function pointerX(event) {
      if (event.touches) return event.touches[0].clientX;
      else return event.clientX;
    }

    function calculateTargetX(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      let x = ((pointerX(event) - rect.left) / rect.width) * 2 - 1;
      x *= camera.aspect * camera.position.z * Math.tan(camera.fov/2*Math.PI/180);
      return Math.max(-GUN_X_LIMIT, Math.min(GUN_X_LIMIT, x));
    }

    renderer.domElement.addEventListener("pointermove", e => {
      if (gunMoving) targetGunX = calculateTargetX(e);
    });
    window.addEventListener("pointerup", e => { gunMoving = false; });

    // Zombies
    function createZombie() {
      const zombie = new THREE.Group();
      const hue = Math.random() * 0.2 + 0.3; 
      const saturation = 0.7 + Math.random() * 0.2;
      const lightnessBody = 0.3 + Math.random() * 0.1;
      const lightnessHead = 0.4 + Math.random() * 0.1;

      const head = new THREE.Mesh(
        new THREE.BoxGeometry(1.1, 1.2, 1.1),
        new THREE.MeshPhongMaterial({color: new THREE.Color().setHSL(hue, saturation, lightnessHead), shininess: 50}) // Added shininess
      );
      head.position.y = 0.7;
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.7, 1.2, 0.7),
        new THREE.MeshPhongMaterial({color: new THREE.Color().setHSL(hue, saturation, lightnessBody), shininess: 50}) // Added shininess
      );
      body.position.y = -0.4;
      zombie.add(head); zombie.add(body);
      const eye1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.16, 0.16, 0.05),
        new THREE.MeshPhongMaterial({color: 0x000000})
      );
      eye1.position.set(-0.22, 1.03, 0.61);
      const eye2 = eye1.clone(); eye2.position.x = 0.22;
      zombie.add(eye1); zombie.add(eye2);
      zombie.position.x = (Math.random() - 0.5) * (GUN_X_LIMIT * 2); 
      zombie.position.y = 13;
      zombie.position.z = (Math.random() - 0.5) * 2;
      zombie.userData = { speed: 0.027 + Math.random()*0.018, dead: false, type: 'zombie', collisionRadius: 1.05 };
      return zombie;
    }

    // Aliens
    function createAlien() {
        const alien = new THREE.Group();
        const bodyGeo = new THREE.ConeGeometry(0.7, 1.2, 4); 
        const headGeo = new THREE.SphereGeometry(0.4, 16, 16); 

        const alienHue = Math.random() * 0.2 + 0.6; 
        const alienSaturation = 0.8;
        const alienLightness = 0.5;

        const bodyMat = new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(alienHue, alienSaturation, alienLightness), shininess: 50 }); // Added shininess
        const headMat = new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(alienHue + 0.05, alienSaturation - 0.2, alienLightness + 0.2), shininess: 50 }); // Added shininess

        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.6; 
        alien.add(body);

        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 1.2 + 0.4; 
        alien.add(head);

        alien.position.x = (Math.random() - 0.5) * (GUN_X_LIMIT * 2); 
        alien.position.y = 13;
        alien.position.z = (Math.random() - 0.5) * 2;
        alien.userData = { speed: 0.035 + Math.random()*0.02, dead: false, type: 'alien', collisionRadius: 0.8 }; 
        return alien;
    }

    // Spawning logic for both zombies and aliens
    setInterval(() => {
      const maxFallingObjects = 8 + Math.floor(score/10); 
      if (fallingObjects.length < maxFallingObjects) {
        let newObject;
        if (Math.random() < 0.6) { 
          newObject = createZombie();
        } else { 
          newObject = createAlien();
        }
        scene.add(newObject);
        fallingObjects.push(newObject);
      }
    }, 700); 

    // Bullets
    function createBullet() {
      const geometry = new THREE.CylinderGeometry(0.11, 0.11, 0.7, 12);
      const bulletHue = Math.random(); 
      const bulletMaterial = new THREE.MeshPhongMaterial({color: new THREE.Color().setHSL(bulletHue, 0.9, 0.6), shininess: 100}); // Added shininess
      const bullet = new THREE.Mesh(geometry, bulletMaterial);
      
      bullet.rotation.x = Math.PI / 2; 

      const gunModelHeight = 2.3; // Approx total height of the gun model from its base
      bullet.position.set(gun.position.x, GUN_Y + gunModelHeight, 0); 
      bullet.userData = { speed: 0.55, alive: true };
      return bullet;
    }
    setInterval(() => {
      bullets.push(createBullet());
      scene.add(bullets[bullets.length-1]);
    }, 110);

    // Bullet-Falling Object collision
    function checkBulletFallingObjectCollisions() {
      for (let i = bullets.length-1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.position.y += bullet.userData.speed;
        if (bullet.position.y > 14) { 
          scene.remove(bullet);
          bullets.splice(i,1);
          continue;
        }
        for (let j = fallingObjects.length-1; j >= 0; j--) {
          const obj = fallingObjects[j];
          if (obj.userData.dead) continue;
          
          const dist = bullet.position.distanceTo(obj.position);
          const collisionRadius = obj.userData.collisionRadius || 1.05; 

          if (dist < collisionRadius) { 
            obj.userData.dead = true;
            if (!soundMuted && audioUnlocked) { // Play only if not muted AND audio is unlocked
              try { 
                zombieHitSound.currentTime = 0; 
                zombieHitSound.play().catch(err => console.error("Sound play error (hit):", err)); 
              } catch(e){ 
                console.error("Critical sound play error (hit):", e); 
              }
            }
            score++;
            document.getElementById('score').textContent = 'Score: ' + score;
            scene.remove(bullet);
            bullets.splice(i,1);
            break; 
          }
        }
      }
    }

    // Animate
    function animate() {
      requestAnimationFrame(animate);

      // Smoothly move the gun towards the targetX
      if (gunMoving) {
        gun.position.x += (targetGunX - gun.position.x) * dragSensitivity;
      }

      // Animate falling objects
      for (let i = fallingObjects.length-1; i >= 0; i--) {
        let obj = fallingObjects[i];
        if (obj.userData.dead) {
          obj.scale.multiplyScalar(1.14); 
          obj.children.forEach(child => {
            if (child.material && child.material.opacity !== undefined) {
                child.material.opacity *= 0.80;
                child.material.transparent = true;
            } else if (child.material) {
                child.material.opacity = 0.8;
                child.material.transparent = true;
            }
          });
          if (obj.scale.x > 2.4) { 
            scene.remove(obj);
            fallingObjects.splice(i,1);
          }
        } else {
          obj.position.y -= obj.userData.speed;
          obj.rotation.y += 0.004; 
          if (obj.position.y < GUN_Y - 0.7) { 
            if (!soundMuted && audioUnlocked) { // Play only if not muted AND audio is unlocked
              try { 
                zombieHitSound.currentTime = 0.18; 
                zombieHitSound.play().catch(err => console.error("Sound play error (miss):", err)); 
              } catch(e){ 
                console.error("Critical sound play error (miss):", e); 
              }
            }
            scene.remove(obj);
            fallingObjects.splice(i,1);
          }
        }
      }
      checkBulletFallingObjectCollisions();
      renderer.render(scene, camera);
    }
    animate();

    // Responsive setup: recalculate camera and gun position on resize
    window.addEventListener('resize', updateCameraAndGunPlacement);
  </script>
</body>
</html>