<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Zombie Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body { margin:0; padding:0; overflow: hidden; background: #222; height: 100%; width: 100%; }
    #score {
      position: absolute; top: 16px; left: 20px; color: #fff; font-size: 1.5rem;
      background: rgba(44,83,100,0.6); border-radius: 10px; padding: 7px 22px; z-index: 2;
      font-family: Arial, sans-serif; letter-spacing: 1.5px; box-shadow: 0 2px 16px #0003;
    }
    #info {
      position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
      color: #fff; font-family: Arial, sans-serif; letter-spacing: 0.5px; box-shadow: 0 2px 12px #0001;
      background: rgba(44,83,100,0.6); border-radius: 10px; padding: 7px 22px; z-index: 2;
    }
    #mute-btn {
      position: absolute;
      top: 16px;
      right: 20px;
      z-index: 10;
      background: rgba(44,83,100,0.6);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 16px #0003;
      border: none;
      outline: none;
      transition: background 0.2s;
      padding: 0;
    }
    #mute-btn:active { background: rgba(44,83,100,0.8); }
    #mute-btn svg { width: 28px; height: 28px; }
    @media (max-width: 700px) {
      #score { font-size: 1.1rem; padding: 5px 13px;}
      #info { font-size: 0.8rem; padding: 5px 9px;}
      #mute-btn { width:34px; height:34px; top: 9px; right: 9px;}
      #mute-btn svg { width:20px; height:20px; }
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="info">Drag to move the gun. Shoot falling zombies!</div>
  <button id="mute-btn" aria-label="Mute/unmute sound">
    <svg id="sound-on" viewBox="0 0 24 24" fill="none"><path d="M5 9v6h4l5 5V4l-5 5H5z" fill="#fff"/><path d="M16.5 12c0-1.77-.77-3.29-2-4.29v8.58c1.23-1 2-2.52 2-4.29z" fill="#fff"/></svg>
    <svg id="sound-off" viewBox="0 0 24 24" fill="none" style="display:none"><path d="M16.5 12c0-1.77-.77-3.29-2-4.29v8.58c1.23-1 2-2.52 2-4.29z" fill="#fff"/><path d="M5 9v6h4l5 5V4l-5 5H5z" fill="#fff"/><line x1="19" y1="5" x2="5" y2="19" stroke="#fff" stroke-width="2"/></svg>
  </button>
  <audio id="zombie-hit-sound" src="https://cdn.pixabay.com/audio/2022/10/16/audio_12d9e.mp3"></audio>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, gun, zombies = [], bullets = [], score = 0;
    let GUN_Y = -8.5, GUN_X_LIMIT = 9.5, gunMoving = false, soundMuted = false;
    let targetGunX = 0; // Target X position for smoother gun movement
    const dragSensitivity = 0.1; // Adjust this value for desired responsiveness (0.01 for very smooth, 0.5 for very responsive)

    // Sound
    const zombieHitSound = document.getElementById('zombie-hit-sound');
    zombieHitSound.volume = 0.2;
    const muteBtn = document.getElementById('mute-btn');
    const soundOnIcon = document.getElementById('sound-on');
    const soundOffIcon = document.getElementById('sound-off');

    let audioContext; // Will be initialized on first user interaction

    function setMuteUI(muted) {
      soundOnIcon.style.display = muted ? "none" : "";
      soundOffIcon.style.display = muted ? "" : "none";
    }

    // Event listener for first user interaction to resume AudioContext
    muteBtn.addEventListener('click', () => {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log('AudioContext resumed!');
          }).catch(e => console.error("Failed to resume AudioContext:", e));
        }
      }
      soundMuted = !soundMuted;
      setMuteUI(soundMuted);
    });

    // Three.js setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 22);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.DirectionalLight(0xffffff, 0.7).position.set(0, 3, 7));
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    scene.add(new THREE.Mesh(
      new THREE.SphereGeometry(200,32,32),
      new THREE.MeshBasicMaterial({color: 0x23272a, side:THREE.BackSide})
    ));

    // Gun Model - Modified to point upwards
    function createGun() {
      const gunGroup = new THREE.Group();
      // Body of the gun (base)
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.8, 0.5), // width, height, depth
        new THREE.MeshPhongMaterial({color: 0x333333})
      );
      body.position.y = 0.4; // Center at 0.4 for a height of 0.8, putting base at 0

      // Barrel of the gun
      const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.14, 0.14, 1.5, 18), // radius, radius, height, segments
        new THREE.MeshPhongMaterial({color: 0x90caf9})
      );
      // Cylinder is by default aligned with Y-axis, so no rotation needed for 'up'
      barrel.position.y = 0.8 + (1.5 / 2); // Position on top of the body

      // Muzzle (top of the barrel)
      const muzzle = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 12, 12),
        new THREE.MeshPhongMaterial({color: 0xffab00})
      );
      muzzle.position.y = 0.8 + 1.5; // Position at the very top of the barrel

      gunGroup.add(body);
      gunGroup.add(barrel);
      gunGroup.add(muzzle);
      gunGroup.position.set(0, GUN_Y, 0); // Initial global position of the gun
      return gunGroup;
    }
    gun = createGun(); scene.add(gun);

    // Gun movement (touch/mouse)
    function pointerX(event) {
      if (event.touches) return event.touches[0].clientX;
      else return event.clientX;
    }

    function calculateTargetX(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      let x = ((pointerX(event) - rect.left) / rect.width) * 2 - 1;
      x *= camera.aspect * camera.position.z * Math.tan(camera.fov/2*Math.PI/180);
      return Math.max(-GUN_X_LIMIT, Math.min(GUN_X_LIMIT, x));
    }

    renderer.domElement.addEventListener("pointerdown", e => {
      gunMoving = true;
      targetGunX = calculateTargetX(e); // Set initial target
    });
    renderer.domElement.addEventListener("pointermove", e => {
      if (gunMoving) targetGunX = calculateTargetX(e);
    });
    window.addEventListener("pointerup", e => { gunMoving = false; });

    // Zombies
    function createZombie() {
      const zombie = new THREE.Group();

      // Randomize zombie colors (greenish to brownish hues)
      const hue = Math.random() * 0.2 + 0.3; // Hue from ~green (0.3) to ~yellow-green (0.5)
      const saturation = 0.7 + Math.random() * 0.2; // 0.7 to 0.9
      const lightnessBody = 0.3 + Math.random() * 0.1; // 0.3 to 0.4 for body
      const lightnessHead = 0.4 + Math.random() * 0.1; // 0.4 to 0.5 for head

      const head = new THREE.Mesh(
        new THREE.BoxGeometry(1.1, 1.2, 1.1),
        new THREE.MeshPhongMaterial({color: new THREE.Color().setHSL(hue, saturation, lightnessHead)})
      );
      head.position.y = 0.7;
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.7, 1.2, 0.7),
        new THREE.MeshPhongMaterial({color: new THREE.Color().setHSL(hue, saturation, lightnessBody)})
      );
      body.position.y = -0.4;
      zombie.add(head); zombie.add(body);
      const eye1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.16, 0.16, 0.05),
        new THREE.MeshPhongMaterial({color: 0x000000})
      );
      eye1.position.set(-0.22, 1.03, 0.61);
      const eye2 = eye1.clone(); eye2.position.x = 0.22;
      zombie.add(eye1); zombie.add(eye2);
      zombie.position.x = (Math.random() - 0.5) * 17;
      zombie.position.y = 13;
      zombie.position.z = (Math.random() - 0.5) * 2;
      zombie.userData = { speed: 0.027 + Math.random()*0.018, dead: false };
      return zombie;
    }
    function spawnZombie() {
      const zombie = createZombie();
      scene.add(zombie);
      zombies.push(zombie);
    }
    setInterval(() => {
      if (zombies.length < 8 + Math.floor(score/10)) spawnZombie();
    }, 700);

    // Bullets
    function createBullet() {
      const geometry = new THREE.CylinderGeometry(0.11, 0.11, 0.7, 12);
      // Randomize bullet color
      const bulletHue = Math.random(); // Full spectrum of colors
      const bulletMaterial = new THREE.MeshPhongMaterial({color: new THREE.Color().setHSL(bulletHue, 0.9, 0.6), shininess: 60});
      const bullet = new THREE.Mesh(geometry, bulletMaterial);
      
      // Rotate bullet to point upwards, similar to gun's barrel
      bullet.rotation.x = Math.PI / 2; // Make cylinder point along Z-axis (default is Y)
      bullet.rotation.z = Math.PI / 2; // Then rotate around Z to make it point along Y-axis

      // Set bullet's initial position at the top of the gun
      // Gun's total height is approx 2.3 (0.8 body + 1.5 barrel)
      bullet.position.set(gun.position.x, GUN_Y + 2.3, 0); 
      bullet.userData = { speed: 0.55, alive: true };
      return bullet;
    }
    setInterval(() => {
      bullets.push(createBullet());
      scene.add(bullets[bullets.length-1]);
    }, 110);

    // Bullet-Zombie collision
    function checkBulletZombieCollisions() {
      for (let i = bullets.length-1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.position.y += bullet.userData.speed;
        if (bullet.position.y > 14) { // Bullet goes off screen
          scene.remove(bullet);
          bullets.splice(i,1);
          continue;
        }
        for (let j = zombies.length-1; j >= 0; j--) {
          const zombie = zombies[j];
          if (zombie.userData.dead) continue;
          const dist = bullet.position.distanceTo(zombie.position);
          if (dist < 1.05) { // Collision detected
            zombie.userData.dead = true;
            if (!soundMuted) {
              try { 
                zombieHitSound.currentTime = 0; // Reset sound to beginning
                zombieHitSound.play(); 
              } catch(e){ 
                console.error("Sound play error:", e); 
              }
            }
            score++;
            document.getElementById('score').textContent = 'Score: ' + score;
            scene.remove(bullet);
            bullets.splice(i,1);
            break; // Bullet can only hit one zombie
          }
        }
      }
    }

    // Animate
    function animate() {
      requestAnimationFrame(animate);

      // Smoothly move the gun towards the targetX
      if (gunMoving) {
        gun.position.x += (targetGunX - gun.position.x) * dragSensitivity;
      }

      // Animate zombies
      for (let i = zombies.length-1; i >= 0; i--) {
        let z = zombies[i];
        if (z.userData.dead) {
          z.scale.multiplyScalar(1.14);
          z.children.forEach(child => {
            if (child.material && child.material.opacity !== undefined) {
                child.material.opacity *= 0.80;
                child.material.transparent = true;
            } else if (child.material) {
                child.material.opacity = 0.8;
                child.material.transparent = true;
            }
          });
          if (z.scale.x > 2.4) { // Remove faded zombie
            scene.remove(z);
            zombies.splice(i,1);
          }
        } else {
          z.position.y -= z.userData.speed;
          z.rotation.y += 0.004;
          if (z.position.y < GUN_Y - 0.7) { // Zombie passed the gun
            if (!soundMuted) {
              try { 
                // Play a different sound or effect for missed zombies, or just the same hit sound
                zombieHitSound.currentTime = 0.18; // A different part of the sound, or a distinct 'miss' sound
                zombieHitSound.play(); 
              } catch(e){ 
                console.error("Sound play error (missed zombie):", e); 
              }
            }
            scene.remove(z);
            zombies.splice(i,1);
          }
        }
      }
      checkBulletZombieCollisions();
      renderer.render(scene, camera);
    }
    animate();

    // Responsive
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>