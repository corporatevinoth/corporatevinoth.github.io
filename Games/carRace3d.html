<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Endless Racing Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    html, body { margin:0; padding:0; height:100%; }
    body { background: linear-gradient(135deg,#b6f0ff 0%,#ffecd2 100%); overflow: hidden;}
    #score {
      position: absolute;
      top: 24px; left: 0; right: 0;
      color: #fff700;
      font-family: 'Arial Black', Arial, sans-serif;
      font-size: 2em;
      text-align: center;
      text-shadow: 2px 2px 8px #333;
      z-index: 10;
      letter-spacing: 2px;
      pointer-events: none;
    }
    .ctrl-btn {
      width: 18vw; max-width: 100px; min-width: 60px;
      aspect-ratio: 1/1;
      border-radius: 50%;
      background: #2C387E;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 18px #0006;
      font-size: 3em;
      color: #fff;
      border: 3px solid #fff;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
      transition: background 0.18s, color 0.18s;
      opacity: 0.96;
      position: fixed;
      bottom: 4vh; z-index: 100;
    }
    #leftBtn { right: 4vw; }
    #rightBtn { left: 4vw; }
    .ctrl-btn:active {
      background: #FFD600;
      color: #1a237e;
    }
    #threejs-canvas {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 1;
      display: block;
      touch-action: none;
    }
    @media (max-width: 600px) {
      #score { font-size: 1.25em;}
      .ctrl-btn { font-size: 2em; min-width: 50px;}
    }
  </style>
</head>
<body>
<div id="score">Distance: 0 m</div>
<div class="ctrl-btn" id="rightBtn">&#8592;</div>
<div class="ctrl-btn" id="leftBtn">&#8594;</div>
<button id="speakerBtn" title="Toggle sound" style="position:fixed;right:12px;top:12px;z-index:999;background:transparent;border:none;font-size:1.6rem;cursor:pointer;">ðŸ”Š</button>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 500);
let renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.id = "threejs-canvas";
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth,window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});

// Lighting
let light = new THREE.DirectionalLight(0xffffff, 1.1);
light.position.set(0, 20, 15);
scene.add(light);
scene.add(new THREE.AmbientLight(0xf3e5ab, 0.7));

// --- Begin Endless Black Road ---
let roadSegments = [];
const ROAD_WIDTH = 12;
const ROAD_LENGTH = 100;
const NUM_ROAD_SEGMENTS = 4;

function createRoadSegment(zPos) {
  let mat = new THREE.MeshPhongMaterial({color:0x000000});
  let geo = new THREE.BoxGeometry(ROAD_WIDTH, 0.6, ROAD_LENGTH);
  let mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(0, -0.6, zPos);
  scene.add(mesh);
  return mesh;
}
for(let i=0; i<NUM_ROAD_SEGMENTS; i++) {
  let seg = createRoadSegment(i * ROAD_LENGTH);
  roadSegments.push(seg);
}
// --- End Endless Black Road ---

// Lane markers (now endless)
let laneMarkers = [];
const NUM_LANE_MARKERS = 30;
for(let i=0; i<NUM_LANE_MARKERS; i++) {
  let geo = new THREE.BoxGeometry(0.3,0.05,4);
  let mat = new THREE.MeshPhongMaterial({color:0xffffff});
  let mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(0,0.1,i*10+5);
  scene.add(mesh);
  laneMarkers.push(mesh);
}

// Sports car model with better design
function createCar(color=0x1e88e5, y=0, isPlayer=true) {
  let group = new THREE.Group();
  
  // Main body - sports car shape
  let bodyMat = new THREE.MeshPhongMaterial({color, shininess: 100});
  let body = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.7, 3.8), bodyMat);
  body.position.set(0, y+0.5, 0);
  body.castShadow = true;
  group.add(body);
  
  // Roofline - sloped
  let roofMat = new THREE.MeshPhongMaterial({color: 0xcfd8dc});
  let roof = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.5, 2.0), roofMat);
  roof.position.set(0, y+1.15, -0.3);
  roof.castShadow = true;
  group.add(roof);
  
  // Front bumper/spoiler
  let frontSpoiler = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.3, 0.4), new THREE.MeshPhongMaterial({color: 0x000}));
  frontSpoiler.position.set(0, y+0.35, 1.95);
  group.add(frontSpoiler);
  
  // Headlights
  for(let x of [-0.6, 0.6]) {
    let light = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshPhongMaterial({color: 0xffff00, emissive: 0xffff00}));
    light.position.set(x, y+0.6, 2.0);
    group.add(light);
  }
  
  // Back spoiler
  let rearSpoiler = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.4, 0.35), new THREE.MeshPhongMaterial({color: 0x111}));
  rearSpoiler.position.set(0, y+0.7, -1.95);
  group.add(rearSpoiler);
  
  // Windows
  let windowMat = new THREE.MeshPhongMaterial({color: 0x87ceeb, transparent: true, opacity: 0.6});
  let frontWindow = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.35, 1.0), windowMat);
  frontWindow.position.set(0, y+1.0, 0.3);
  group.add(frontWindow);
  
  // Wheels - sport design
  let wheelMat = new THREE.MeshPhongMaterial({color: 0x222});
  for(let dx of [-0.8, 0.8]) {
    for(let dz of [-1.2, 1.2]) {
      let wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.25, 32), wheelMat);
      wheel.rotation.z = Math.PI/2;
      wheel.position.set(dx, y+0.2, dz);
      wheel.castShadow = true;
      group.add(wheel);
      
      // Wheel rim
      let rim = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.06, 16, 32), new THREE.MeshPhongMaterial({color: 0xaaa}));
      rim.rotation.y = Math.PI/2;
      rim.position.set(dx, y+0.2, dz);
      group.add(rim);
    }
  }
  
  group.position.set(0, 0, 4);
  group.userData = {color, isPlayer};
  return group;
}

// Player car
let player = createCar(0x1976d2, 0,true);
player.position.z = 6;
scene.add(player);

// AI cars
let aiCars = [];
const aiColors = [0xd32f2f, 0x388e3c, 0xfbc02d, 0x6d4c41, 0x1976d2, 0x7b1fa2, 0xff5722];
for(let i=0;i<7;i++) {
  let car = createCar(aiColors[i%aiColors.length],0,false);
  car.position.x = [-4, -2, 0, 2, 4][i%5];
  car.position.z = 2-i*6;
  scene.add(car);
  aiCars.push({obj:car, lane:i%3, speed:0.42+Math.random()*0.16});
}

// Speed boosts
let boosts = [];
function createBoost(x, z) {
  let geo = new THREE.TorusGeometry(0.6, 0.18, 16, 32);
  let mat = new THREE.MeshPhongMaterial({color:0x00e676, emissive:0x5cffd5, emissiveIntensity:0.7});
  let mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x,0.5,z);
  mesh.rotation.x = Math.PI/2;
  scene.add(mesh);
  boosts.push(mesh);
}
function spawnBoosts() {
  boosts.forEach(b=>scene.remove(b));
  boosts = [];
  for(let i=0;i<8;i++) {
    let lane = [-4, 0, 4][Math.floor(Math.random()*3)];
    createBoost(lane, 24+Math.random()*250);
  }
}
spawnBoosts();

// Decorations: trees
let decorations = [];
function createTree(x, z) {
  let group = new THREE.Group();
  let trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.17,0.21,1.2,8), new THREE.MeshPhongMaterial({color:0x8d5524}));
  trunk.position.y = 0.6;
  let leaves = new THREE.Mesh(new THREE.SphereGeometry(0.66,12,10), new THREE.MeshPhongMaterial({color:0x388e3c}));
  leaves.position.y = 1.3;
  group.add(trunk); group.add(leaves);
  group.position.set(x,0,z);
  scene.add(group);
  decorations.push(group);
}
for(let i=0;i<44;i++) {
  createTree(-9.5-Math.random()*2, 7+i*7+Math.random()*5);
  createTree(9.5+Math.random()*2, 7+i*7+Math.random()*5);
}

// Buildings on both sides
let buildings = [];
function createBuilding(x, z) {
  let group = new THREE.Group();
  let height = 2 + Math.random() * 5;
  let color = [0xffe082, 0x80cbc4, 0xd1c4e9, 0xffab91][Math.floor(Math.random() * 4)];
  let building = new THREE.Mesh(
    new THREE.BoxGeometry(1.6 + Math.random() * 1.6, height, 2.8 + Math.random() * 1.8),
    new THREE.MeshPhongMaterial({ color })
  );
  building.position.y = height / 2;
  group.add(building);
  group.position.set(x, 0, z);
  scene.add(group);
  buildings.push(group);
}
for(let i=0;i<44;i++) {
  createBuilding(-11.5-Math.random()*2, 7+i*7+Math.random()*5);
  createBuilding(11.5+Math.random()*2, 7+i*7+Math.random()*5);
}

// Controls
// Game state
let speed = 0;
let scoreDiv = document.getElementById("score");
let boosting = false, boostTime=0, boostDuration=60;
let distance = 0;

// Keyboard state
let keys = {arrowUp: false, arrowDown: false};
const MAX_SPEED = 1.2;
const ACCELERATION = 0.04;
const DECELERATION = 0.03;

// Sound manager
let audioContext = null;
let masterGain = null;
let soundEnabled = true;
function initAudio() {
  if(!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioContext.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioContext.destination);
  }
}

function playSound(type, duration=0.2) {
  if(typeof soundEnabled !== 'undefined' && !soundEnabled) return;
  if(!audioContext) initAudio();
  let now = audioContext.currentTime;
  let osc = audioContext.createOscillator();
  let gain = audioContext.createGain();
  osc.connect(gain);
  if (masterGain) gain.connect(masterGain); else gain.connect(audioContext.destination);
  
  if(type === 'accelerate') {
    osc.frequency.setValueAtTime(400, now);
    osc.frequency.linearRampToValueAtTime(600, now+duration);
  } else if(type === 'brake') {
    osc.frequency.setValueAtTime(300, now);
    osc.frequency.linearRampToValueAtTime(100, now+duration);
  } else if(type === 'collision') {
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(100, now+duration);
  } else if(type === 'boost') {
    osc.frequency.setValueAtTime(1000, now);
    osc.frequency.linearRampToValueAtTime(1200, now+duration);
  }
  
  gain.gain.setValueAtTime(0.3, now);
  gain.gain.exponentialRampToValueAtTime(0.01, now+duration);
  osc.start(now);
  osc.stop(now+duration);
}

// Speaker button and audio resume/persistence
const speakerBtn = document.getElementById('speakerBtn');
function updateSpeakerIcon() {
  if(!speakerBtn) return;
  speakerBtn.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
}
function setSoundEnabled(enabled) {
  soundEnabled = !!enabled;
  if(!audioContext) {
    try { initAudio(); } catch(e) {}
  }
  if(masterGain) masterGain.gain.value = soundEnabled ? 1.0 : 0.0;
  try { localStorage.setItem('carRace3d_sound', soundEnabled ? '1' : '0'); } catch(e) {}
  updateSpeakerIcon();
}

// Load persisted preference
try {
  const stored = localStorage.getItem('carRace3d_sound');
  if(stored !== null) soundEnabled = stored !== '0';
} catch(e) {}
updateSpeakerIcon();

if(speakerBtn) {
  speakerBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    // Ensure audio context exists and is resumed on user gesture
    if(!audioContext) initAudio();
    if(audioContext && audioContext.state === 'suspended') audioContext.resume();
    setSoundEnabled(!soundEnabled);
  });
}

// One-time resume on first user gesture to unlock audio
function resumeOnFirstGesture() {
  if(!audioContext) initAudio();
  if(audioContext && audioContext.state === 'suspended') audioContext.resume();
  document.removeEventListener('pointerdown', resumeOnFirstGesture);
}
document.addEventListener('pointerdown', resumeOnFirstGesture, {passive:true});

window.addEventListener('keydown', function(e){
  if(e.key==='ArrowUp') {keys.arrowUp = true; playSound('accelerate', 0.1);}
  if(e.key==='ArrowDown') {keys.arrowDown = true; playSound('brake', 0.15);}
  if(e.key==='ArrowLeft'||e.key==='a') moveLeft();
  if(e.key==='ArrowRight'||e.key==='d') moveRight();
});

window.addEventListener('keyup', function(e){
  if(e.key==='ArrowUp') keys.arrowUp = false;
  if(e.key==='ArrowDown') keys.arrowDown = false;
});

// Endless recycling
function recycleObject(obj, range = 300) {
  if (obj.position.z < player.position.z - 10) {
    obj.position.z += range + Math.random() * 50;
  }
}

// --- Endless Road Recycle Logic ---
function recycleRoadSegments() {
  roadSegments.forEach(seg => {
    if(seg.position.z + ROAD_LENGTH < player.position.z - 10) {
      seg.position.z += NUM_ROAD_SEGMENTS * ROAD_LENGTH;
    }
  });
}
// --- End Road Recycle Logic ---

// Recycle lane markers
function recycleLaneMarkers() {
  laneMarkers.forEach(marker => {
    if(marker.position.z < player.position.z - 10) {
      marker.position.z += NUM_LANE_MARKERS * 10;
    }
  });
}

// Main loop
function animate() {
  // Player movement and controls
  let tx = lanes[targetLane];
  player.position.x += (tx-player.position.x)*0.18;
  
  // Speed control with arrow keys
  if(keys.arrowUp) {
    speed = Math.min(MAX_SPEED, speed + ACCELERATION);
  } else if(keys.arrowDown) {
    speed = Math.max(0, speed - DECELERATION);
  } else {
    speed = Math.max(0, speed - DECELERATION*0.5); // Gradual deceleration
  }
  
  if(boosting) speed = Math.min(1.5, speed * 1.2);
  
  player.position.z += speed;
  distance = Math.floor(player.position.z);

  // AI logic
  aiCars.forEach((a, i) => {
    a.obj.position.z += a.speed + Math.sin(Date.now()/1200+i)*0.05;
    
    // Change lane randomly
    if(Math.random()<0.012){
      let newLane = Math.floor(Math.random()*3);
      a.lane = newLane;
    }
    let tx = lanes[a.lane];
    a.obj.position.x += (tx-a.obj.position.x)*0.13;
    
    // Collision detection with player
    let dx = player.position.x - a.obj.position.x;
    let dz = player.position.z - a.obj.position.z;
    let dist = Math.sqrt(dx*dx + dz*dz);
    
    if(dist < 2.5) {
      playSound('collision', 0.3);
      // Push AI car away
      let angle = Math.atan2(dz, dx);
      a.obj.position.x -= Math.cos(angle) * 0.3;
      a.obj.position.z -= Math.sin(angle) * 0.3;
      // Slow down player slightly
      speed *= 0.8;
    }
    
    // Endless loop AI cars
    if(a.obj.position.z < player.position.z - 20) {
      a.obj.position.z = player.position.z + 200;
      a.obj.position.x = [-4, -2, 0, 2, 4][Math.floor(Math.random()*5)];
      a.speed = 0.42 + Math.random() * 0.16;
    }
  });

  // Boosts
  for(let i=boosts.length-1;i>=0;i--) {
    let b = boosts[i];
    b.rotation.z += 0.09;
    if(
      Math.abs(player.position.z-b.position.z)<2.2 &&
      Math.abs(player.position.x-b.position.x)<2.1
    ) {
      scene.remove(b);
      boosts.splice(i,1);
      boosting = true; 
      boostTime=boostDuration;
      playSound('boost', 0.2);
    }
  }
  if(boosting) {
    boostTime--;
    if(boostTime<=0) boosting=false;
  }
  if(boosts.length<3) spawnBoosts();

  // Endless decorations
  decorations.forEach(obj=>recycleObject(obj, 300));
  buildings.forEach(obj=>recycleObject(obj, 300));

  // Recycle Road Segments
  recycleRoadSegments();

  // Recycle Lane Markers
  recycleLaneMarkers();

  // Score
  scoreDiv.innerText = "Distance: " + distance + " m | Speed: " + Math.floor(speed*100) + "%";

  updateCamera();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

// Camera follows behind car
function updateCamera() {
  let carPos = player.position;
  camera.position.lerp(
    new THREE.Vector3(carPos.x, carPos.y+4.8, carPos.z-8.5),
    0.16
  );
  camera.lookAt(new THREE.Vector3(carPos.x,carPos.y+1,carPos.z+12));
}

// Car controls
let lanes = [-4, 0, 4], targetLane=1;
function moveLeft() { targetLane=Math.max(0,targetLane-1);}
function moveRight(){ targetLane=Math.min(2,targetLane+1);}

document.getElementById('leftBtn').addEventListener('touchstart', moveLeft);
document.getElementById('leftBtn').addEventListener('mousedown', moveLeft);
document.getElementById('rightBtn').addEventListener('touchstart', moveRight);
document.getElementById('rightBtn').addEventListener('mousedown', moveRight);

animate();

</script>
</body>
</html>
