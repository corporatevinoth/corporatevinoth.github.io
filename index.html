<!DOCTYPE html>
<html>
<head>
  <title>Helicopter Shooter (Mobile)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body { height: 100%; margin: 0; padding: 0; background: #222; overflow: hidden; }
    body { width: 100vw; height: 100vh; }
    canvas { display: block; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; touch-action: none; background: #222; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function getUnit() {
      return Math.min(canvas.width, canvas.height) / 20;
    }

    let unit = getUnit();
    function updateUnits() {
      unit = getUnit();
      helicopter.speed = unit * 0.5;
      helicopter.width = unit * 2;
      helicopter.height = unit;
      bulletSize = unit * 0.2;
      bulletSpeed = unit * 1;
      regularBalloonSize = unit * 1.5;
      bonusBalloonSize = unit * 2.4; // larger for bonus
      balloonSpeed = unit * 0.1;
    }

    const helicopter = { x: 0, y: 0, speed: 0, width: 0, height: 0 };
    helicopter.x = canvas.width / 2;
    helicopter.y = canvas.height * 0.8;

    const fireRate = 100;
    let lastFireTime = 0;
    let bulletSpeed = 15;
    let bulletSize = 3;

    // Balloons array: now each has type, size, and score
    const balloons = [];
    const balloonSpawnInterval = 800;
    let lastBalloonSpawnTime = 0;
    let balloonSpeed = 1.5;
    let regularBalloonSize = 30;
    let bonusBalloonSize = 50;

    // Load balloon image (same for regular & bonus, or use a different one)
    const balloonImg = new Image();
    balloonImg.src = 'balloon.gif';

    let score = 0;
    let isTouchingLeft = false;
    let isTouchingRight = false;

    // Spawn either regular or bonus balloon
    function spawnBalloon() {
      const isBonus = Math.random() < 0.15; // 15% chance for bonus
      const size = isBonus ? bonusBalloonSize : regularBalloonSize;
      const balloonType = isBonus ? 'bonus' : 'regular';
      const balloonScore = isBonus ? 4 : 1;
      const x = Math.random() * (canvas.width - size) + size / 2;
      const y = -size;
      balloons.push({ x, y, size, type: balloonType, score: balloonScore });
    }

    function updateBalloons() {
      for (let i = 0; i < balloons.length; i++) {
        const balloon = balloons[i];
        balloon.y += balloonSpeed;
        const dx = helicopter.x - balloon.x;
        const dy = helicopter.y - balloon.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < balloon.size / 2) {
          alert("Game Over! Balloons reached the helicopter.");
          balloons.length = 0;
          bullets.length = 0;
          score = 0;
          return;
        }
        if (balloon.y > canvas.height + balloon.size) {
          balloons.splice(i, 1);
          i--;
        }
      }
    }

    function drawBalloons() {
      balloons.forEach(balloon => {
        if (balloonImg.complete && balloonImg.naturalWidth !== 0) {
          ctx.save();
          // Make bonus balloons a little more visually distinct (e.g. with a thick border)
          if (balloon.type === 'bonus') {
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(balloon.x, balloon.y, balloon.size / 2 + 4, 0, Math.PI * 2);
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 6;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
          }
          ctx.drawImage(
            balloonImg,
            balloon.x - balloon.size / 2,
            balloon.y - balloon.size / 2,
            balloon.size,
            balloon.size
          );
          ctx.restore();
        } else {
          // fallback: draw a red circle if image not loaded
          ctx.beginPath();
          ctx.arc(balloon.x, balloon.y, balloon.size / 2, 0, Math.PI * 2);
          ctx.fillStyle = balloon.type === 'bonus' ? "gold" : "red";
          ctx.fill();
        }
      });
    }

    const bullets = [];
    function updateBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.y -= bulletSpeed;
        for (let j = balloons.length - 1; j >= 0; j--) {
          const balloon = balloons[j];
          const dx = bullet.x - balloon.x;
          const dy = bullet.y - balloon.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < balloon.size / 2) {
            bullets.splice(i, 1);
            balloons.splice(j, 1);
            score += balloon.score; // Use the balloon's score (1 or 4)
            break;
          }
        }
        if (bullet.y < 0) {
          bullets.splice(i, 1);
        }
      }
    }

    function drawBullets() {
      ctx.fillStyle = 'yellow';
      bullets.forEach(bullet => {
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawHelicopter() {
      ctx.fillStyle = 'blue';
      ctx.fillRect(helicopter.x - helicopter.width / 2, helicopter.y - helicopter.height / 2, helicopter.width, helicopter.height);
    }

    function drawScore() {
      ctx.font = `${unit * 1.2}px Arial`;
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.fillText("Score: " + score, canvas.width / 2, unit * 1.5);
    }

    function continuousFire() {
      const currentTime = Date.now();
      if (currentTime - lastFireTime > fireRate) {
        bullets.push({
          x: helicopter.x,
          y: helicopter.y - helicopter.height / 2,
          vx: 0,
          vy: -bulletSpeed
        });
        lastFireTime = currentTime;
      }
    }

    function updateHelicopterMovement() {
      if (isTouchingLeft) {
        helicopter.x -= helicopter.speed;
        if (helicopter.x < helicopter.width / 2) helicopter.x = helicopter.width / 2;
      }
      if (isTouchingRight) {
        helicopter.x += helicopter.speed;
        if (helicopter.x > canvas.width - helicopter.width / 2) helicopter.x = canvas.width - helicopter.width / 2;
      }
    }

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        if (touch.clientX < canvas.width / 2) {
          isTouchingLeft = true;
        } else {
          isTouchingRight = true;
        }
      }
    }, false);

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      isTouchingLeft = false;
      isTouchingRight = false;
    }, false);

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      isTouchingLeft = false;
      isTouchingRight = false;
      for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        if (touch.clientX < canvas.width / 2) {
          isTouchingLeft = true;
        } else {
          isTouchingRight = true;
        }
      }
    }, false);

    function onResize() {
      resizeCanvas();
      updateUnits();
      helicopter.x = canvas.width / 2;
      helicopter.y = canvas.height * 0.8;
    }
    window.addEventListener('resize', onResize);

();

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawScore();
      updateUnits();

      const currentTime = Date.now();
      if (currentTime - lastBalloonSpawnTime > balloonSpawnInterval) {
        spawnBalloon();
        lastBalloonSpawnTime = currentTime;
      }

      updateHelicopterMovement();
      continuousFire();
      updateBalloons();
      drawBalloons();
      updateBullets();
      drawBullets();
      drawHelicopter();

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>